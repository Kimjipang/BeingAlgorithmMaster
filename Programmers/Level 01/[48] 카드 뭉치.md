🧑‍💻 프로그래머스의 [옹알이(2)] 문제이다. 문자열로 된 발음들을 가지는 리스트 babbling을 입력 받는다. 조카가 할 수 있는 발음은 'aya', 'ye', 'woo', 'ma' 4가지 뿐으로서 한 발음을 연속해서 하는 것을 어려워한다. 입력 받은 babbling을 순회하며 조카가 할 수 있는 발음의 개수를 반환하는 문제이다.

```python
def solution(babbling):
    answer = 0
    for word in babbling:
        for available in ['aya', 'ye', 'woo', 'ma']:
            if available * 2 not in word:
                word = word.replace(available, '1')
        if word.isdigit():
            answer += 1

    return answer
```

***📚 풀이법***

1. 조카가 할 수 있는 발음인지를 확인하기 위해 babbling을 순회한다.
2. 조카가 할 수 있는 발음 목록들을 순회하며 연속된 발음이 있는지를 확인하고 없다면 word 내에 available을 '1'로 대체한다. ❗️`if available * 2 not in word` 조건문이 참이어도 available은 word에 없을 수도 있다.
3. 조카가 할 수 있는 발음 목록들을 순회하고 다음 word로 이동하기 전 `word.isdigit()`이 참이라면 word 문자열의 문자들이 전부 조카가 할 수 있는 발음으로 대체되었다는 뜻이기에 `answer +=1` 연산을 수행한다.
4. 모든 word 순회를 마치고 answer 반환하면 끝



## 카드 뭉치

🧑‍💻 프로그래머스의 [카드 뭉치] 문제이다. 문자열로 된 단어들로 이루어져 있는 리스트 cards1과 cards2를 입력 받는다. cards1과 cards2를 조합하여 리스트 goal에 있는 단어들 순서를 만드려고 한다. 다만, cards1과 cards2 요소들의 순서를 바꾸지 않고 조합하여야 한다. 

```python
def solution(cards1, cards2, goal):
    idx1 = 0
    idx2 = 0
    for word in goal:
        if idx1 < len(cards1) and cards1[idx1] == word:
            idx1 += 1
        elif idx2 < len(cards2) and cards2[idx2] == word:
            idx2 += 1
        else:
            return "No"
    return "Yes"
```



***📚 풀이법***

1. 리스트 goal을 순회하면서 word가 cards1에 있는 것인지 cards2에 있는 것인지를 조건문으로 확인한다.
2. 그 어느 것에도 속해있지 않다면 "No"를 반환한다. ❗️요소의 순서가 바뀌지는 않기 때문에 No를 반환해야 한다.
3. 정상적으로 순회를 마치면  "Yes"를 반환하면 끝
